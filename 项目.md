# 项目

## 赛飞奇安全用电智能监测系统 

### 项目介绍

我在学校TopView工作室做了赛飞奇安全用电智能检测系统，客户是赛飞奇光子技术有限公司，主要完成了对用电设备的监控。数据库是MySQL，后台用到SSM(Spring + Spring MVC + MyBatis)，五个人做了三个月的时间。其中我做了公司模块、用户模块和权限模块，我主要负责开发，但是在开发前我在工作室导师的带领下参与了需求分析、数据库设计等工作，后期我参与测试和部署工作。

项目整体结构分为软件服务和硬件服务，软件服务负责与客户端交互，硬件服务负责与设备交互，这样划分的目的是为了方便独立开发，其中一个人负责硬件服务（较为熟悉），另外两个负责软件服务。软件服务主要按照业务划分为两个模块，分为硬件的监控模块和人事的管理模块，这样划分的好处是为了解除两个模块的业务耦合，为了解决两个模块的依赖问题，我们写个公共api模块。



### 问答

**你如果在项目中遇到问题怎么办？**

业务方面 -> 及时找老师沟通

eg. 我负责的用户模块中，需要实现负责人和联系人，我一开始不清楚两者的区别，但是及时找老师沟通后就清楚了（负责人绑定用户，联系人是临时的）。

技术方面 -> 自己先在Google上查问题 > 即使问相关的人 > 在Deadline前解决

eg. 我负责的权限模块中，我不清楚如何实现一个用户和权限解耦的权限管理系统，于是我通过Google了解到RBAC设计思想，但是又不清楚如何实现，于是我请教了周围的同学，了解到Shrio可以进行注解权限控制，最终在老师要求的时间内设计并实现出来

测试方面 -> 及时和测试人员沟通

eg. 搜索不到联系人，我在高铁上与测试人员跟进并定位bug，最终发现是权限配置失误。



**解决什么问题，如何调优的？**

在开发阶段，我注意到数据库占用CPU过高的情况，在压力测试(用JMeter)阶段，我用VisualVM工具监控了系统中线程连接数据库的情况，发现对于一个构建结点树的请求，系统会多次IO访问MySQL，我改进构建代码优化为一次IO，同时使用Guava Cache对请求的数据进行缓存，以达到减少IO，提高系统访问效率的目的



**项目亮点？**





**基于 RBAC 的权限管理模块是什么？**

我实现的权限模块是基于角色的访问控制(Role-Based Access Control)，即通过用户关联角色、角色关联权限的方法来间接地赋予用户权限，它的好处是实现用户和权限的解耦，便于调整批量用户的权限。我设计的是用户和角色多对多，角色和权限多对多，在数据库中实现起来是三张表+两张关联表。系统上的实现是利用Shiro的注解权限控制。



***拓展：RBAC的几种模型？***

*RBAC0，这是RBAC的初始形态，也是最原始、最简单的RBAC版本*

*RBAC1，增加了**角色的分层**（即：子角色），子角色可以**继承**父角色的所有权限；* 

*RBAC2，增加了对角色的一些**限制**：角色互斥、角色容量等；* 

*RBAC3，将RBAC1和RBAC2中的优化部分进行了整合；*



***拓展：其它的权限管理模型？***

UGO (User, Group, Other)：当一个文件创建后，它具有读(r)、写(w)、执行(x)三种操作方式。UGO权限管理方式将访问文件的操作者简单分为三类：文件属主(u)、同组用户(g)与其他组用户(o)

ACL (Access Control List)：UNIX文件权限管理的一个补充，允许你给任何的用户或用户组设置任何文件/目录的访问权限



**MVC 设计思想**

MVC就是
M:Model 模型
V:View 视图
C:Controller 控制器
模型就是封装业务逻辑和数据的一个一个的模块,控制器就是调用这些模块的,视图就主要是你看到的,比如JSP等.
当用户发出请求的时候,控制器根据请求来选择要处理的业务逻辑和要选择的数据,再返回去把结果输出到视图层,这里可能是进行重定向或转发等.



**Spring IOC 和 AOP**

IOC就是典型的**工厂模式**，通过sessionfactory去注入实例。AOP就是典型的**代理模式**的体现。

在传统的程序设计中，当调用者需要被调用者的协助时，通常由调用者来创建被调用者的实例。但在spring里创建被调用者的工作不再由调用者来完成，因此控制反转（IoC）；创建被调用者实例的工作通常由spring容器来完成，然后注入调用者，因此也被称为依赖注入（DI），依赖注入和控制反转是同一个概念。（介绍IOC和DI）

面向方面编程则是在运行时，动态地将代码切入到类的指定方法、指定位置上。

将对象交给容器管理，你只需要在spring配置文件总配置相应的bean，以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类（假设这个类名是A），分配的方法就是调用A的setter方法来注入，而不需要你在A里面new这些bean了。（介绍IOC的实现）



**Spring 的优点？**

1. 降低了组件之间的**耦合性** ，实现了软件各层之间的解耦，属于低侵入式设计，代码的污染极低

2. 可以使用容易提供的众多**服务**，如事务管理，消息服务等

3. 容器提供**单例模式**支持

4. 容器提供了**AOP**技术，利用它很容易实现如权限拦截，运行期监控等功能

5. spring对于主流的应用框架提供了集成支持，如hibernate，JPA，Struts等
6. spring的DI机制降低了业务对象替换的复杂性
7. Spring的高度开放性，并不强制应用完全依赖于Spring，开发者可以自由选择spring的部分或全部



## 部落格

### 问答

**JDBC流程**

1. 加载JDBC驱动程序：在连接数据库之前，首先要加载想要连接的数据库的驱动到JVM（Java虚拟机），这通过java.lang.Class类的静态方法forName(String className)实现。成功加载后，会将Driver类的实例注册到DriverManager类中。
2. 提供JDBC连接的URL
3. 创建数据库的连接

   - 要连接数据库，需要向java.sql.DriverManager请求并获得Connection对象， 该对象就代表一个数据库的连接。

   - 使用DriverManager的getConnectin(String url , String username , String password )方法传入指定的欲连接的数据库的路径、数据库的用户名和 密码来获得。
4. 创建一个Statement

   - 执行静态SQL语句。通常通过Statement实例实现。
   - 执行动态SQL语句。通常通过PreparedStatement实例实现。
   - 执行数据库存储过程。通常通过CallableStatement实例实现。
5. 执行SQL语句
6. 处理结果
     - 执行更新返回的是本次操作影响到的记录数。
     - 执行查询返回的结果是一个ResultSet对象。
     - ResultSet包含符合SQL语句中条件的所有行，并且它通过一套get方法提供了对这些行中数据的访问。

7. 关闭JDBC对象:操作完成以后要把所有使用的JDBC对象全都关闭，以释放JDBC资源